namespace ToDo.Api;

/// <summary>
/// Статичний клас з методами розширення для роботи з тегами в системі ToDo.
/// Надає уніфіковані методи для нормалізації, додавання, видалення та пошуку тегів.
/// </summary>
/// <remarks>
/// TagExtensions забезпечує консистентну роботу з тегами через весь додаток:
/// 
/// <strong>Основні принципи:</strong>
/// - Нормалізація тегів для уникнення дублікатів
/// - Нечутливість до регістру символів
/// - Автоматичне очищення пробілів
/// - Запобігання додавання порожніх тегів
/// 
/// <strong>Методи розширення для List&lt;string&gt;:</strong>
/// - AddTag() - безпечне додавання з перевірками
/// - RemoveTag() - видалення з нормалізацією
/// - HasTag() - пошук без урахування регістру
/// 
/// <strong>Методи розширення для IEnumerable&lt;Todo&gt;:</strong>
/// - GetUniqueTagsFrom() - отримання всіх унікальних тегів
/// 
/// Використання extension methods забезпечує чистий та зрозумілий API
/// для роботи з тегами у всіх частинах додатку.
/// </remarks>
public static class TagExtensions
{
    /// <summary>
    /// Нормалізує тег приводячи його до стандартного формату.
    /// Видаляє зайві пробіли та приводить до нижнього регістру для консистентності.
    /// </summary>
    /// <param name="tag">Рядок тегу який потребує нормалізації.</param>
    /// <returns>
    /// Нормалізований тег у нижньому регістрі без зайвих пробілів.
    /// </returns>
    /// <remarks>
    /// Процес нормалізації включає:
    /// 1. <strong>Trim()</strong> - видалення пробілів на початку та в кінці
    /// 2. <strong>ToLowerInvariant()</strong> - приведення до нижнього регістру
    /// 
    /// <strong>Приклади нормалізації:</strong>
    /// - "  Work  " → "work"
    /// - "HIGH-PRIORITY" → "high-priority"  
    /// - "Personal" → "personal"
    /// 
    /// ToLowerInvariant() використовується замість ToLower() для
    /// забезпечення консистентної поведінки незалежно від культури системи.
    /// 
    /// Цей метод є основою для всіх інших операцій з тегами,
    /// забезпечуючи уніфікований підхід до їх обробки.
    /// </remarks>
    public static string NormalizeTag(this string tag)
    {
        return tag.Trim().ToLowerInvariant();
    }

    /// <summary>
    /// Додає новий тег до списку з автоматичною нормалізацією та перевіркою дублікатів.
    /// Запобігає додаванню порожніх тегів та дублікатів у списку.
    /// </summary>
    /// <param name="tags">Список тегів до якого додається новий тег.</param>
    /// <param name="tag">Рядок тегу для додавання до списку.</param>
    /// <remarks>
    /// Алгоритм додавання тегу:
    /// 
    /// 1. <strong>Нормалізація:</strong> Приведення тегу до стандартного формату
    /// 2. <strong>Перевірка порожності:</strong> Відхилення порожніх або null значень
    /// 3. <strong>Перевірка дублікатів:</strong> Запобігання додаванню існуючих тегів
    /// 4. <strong>Додавання:</strong> Безпечне додавання до списку
    /// 
    /// <strong>Ситуації коли тег НЕ додається:</strong>
    /// - string.IsNullOrEmpty() повертає true
    /// - Тег вже існує в списку (після нормалізації)
    /// - Тег складається тільки з пробілів
    /// 
    /// <strong>Переваги підходу:</strong>
    /// - Автоматична дедуплікація
    /// - Консистентність форматування
    /// - Безпечність операції
    /// - Простота використання
    /// 
    /// <strong>Приклад використання:</strong>
    /// <code>
    /// var tags = new List&lt;string&gt;();
    /// tags.AddTag("Work");     // Додасть "work"
    /// tags.AddTag("  Work  "); // НЕ додасть (дублікат)
    /// tags.AddTag("");        // НЕ додасть (порожній)
    /// </code>
    /// </remarks>
    public static void AddTag(this List<string> tags, string tag)
    {
        string normalizedTag = tag.NormalizeTag();

        if (!string.IsNullOrEmpty(normalizedTag) && !tags.Contains(normalizedTag))
        {
            tags.Add(normalizedTag);
        }
    }

    /// <summary>
    /// Видаляє тег зі списку з попередньою нормалізацією.
    /// Виконує безпечне видалення навіть якщо тег не існує у списку.
    /// </summary>
    /// <param name="tags">Список тегів з якого видаляється тег.</param>
    /// <param name="tag">Рядок тегу для видалення зі списку.</param>
    /// <remarks>
    /// Процес видалення тегу:
    /// 
    /// 1. <strong>Нормалізація:</strong> Приведення тегу до стандартного формату
    /// 2. <strong>Пошук та видалення:</strong> List.Remove() з нормалізованим значенням
    /// 
    /// <strong>Особливості поведінки:</strong>
    /// - Видаляє тільки ПЕРШИЙ збіг (поведінка List.Remove)
    /// - Не генерує помилок якщо тег не знайдено
    /// - Враховує нормалізацію при пошуку
    /// 
    /// <strong>Нечутливість до регістру:</strong>
    /// Завдяки нормалізації "Work", "WORK", "work" будуть знайдені та видалені.
    /// 
    /// <strong>Приклад використання:</strong>
    /// <code>
    /// var tags = new List&lt;string&gt; {"work", "personal"};
    /// tags.RemoveTag("WORK");     // Видалить "work"
    /// tags.RemoveTag("missing");  // Нічого не станеться
    /// </code>
    /// 
    /// Метод безпечний для використання і не потребує попередньої перевірки
    /// на існування тегу в списку.
    /// </remarks>
    public static void RemoveTag(this List<string> tags, string tag)
    {
        string normalizedTag = tag.NormalizeTag();

        tags.Remove(normalizedTag);
    }

    /// <summary>
    /// Перевіряє чи містить список вказаний тег з урахуванням нормалізації.
    /// Виконує пошук без урахування регістру та зайвих пробілів.
    /// </summary>
    /// <param name="tags">Список тегів для пошуку.</param>
    /// <param name="tag">Рядок тегу який шукається у списку.</param>
    /// <returns>
    /// true якщо тег знайдено у списку (після нормалізації), false якщо не знайдено.
    /// </returns>
    /// <remarks>
    /// Алгоритм пошуку тегу:
    /// 
    /// 1. <strong>Нормалізація пошукового тегу:</strong> Приведення до стандартного формату
    /// 2. <strong>Пошук у списку:</strong> List.Contains() з нормалізованим значенням
    /// 
    /// <strong>Нечутливість до регістру та пробілів:</strong>
    /// Завдяки нормалізації наступні варіанти будуть знайдені як один тег:
    /// - "work", "Work", "WORK", "  work  "
    /// 
    /// <strong>Продуктивність:</strong>
    /// Використовує List.Contains() що має складність O(n) для лінійного пошуку.
    /// Для великих списків тегів може знадобитися оптимізація через HashSet.
    /// 
    /// <strong>Приклад використання:</strong>
    /// <code>
    /// var tags = new List&lt;string&gt; {"work", "personal"};
    /// bool hasWork = tags.HasTag("WORK");      // true
    /// bool hasHome = tags.HasTag("home");      // false
    /// bool hasPersonal = tags.HasTag("  Personal  "); // true
    /// </code>
    /// 
    /// Метод корисний для:
    /// - Фільтрації завдань за тегами
    /// - Валідації наявності тегів
    /// - Умовної логіки в UI
    /// </remarks>
    public static bool HasTag(this List<string> tags, string tag)
    {
        string normalizedTag = tag.NormalizeTag();

        return tags.Contains(normalizedTag);
    }

    /// <summary>
    /// Отримує список всіх унікальних тегів з колекції завдань ToDo.
    /// Об'єднує теги з усіх завдань, видаляє дублікати та сортує за алфавітом.
    /// </summary>
    /// <param name="todos">Колекція завдань ToDo для аналізу тегів.</param>
    /// <returns>
    /// Відсортований список унікальних тегів з усіх завдань.
    /// Повертає порожній список якщо завдання не містять тегів.
    /// </returns>
    /// <remarks>
    /// Алгоритм обробки тегів:
    /// 
    /// 1. <strong>SelectMany():</strong> Об'єднання всіх списків тегів в один потік
    /// 2. <strong>Distinct():</strong> Видалення дублікатів тегів
    /// 3. <strong>OrderBy():</strong> Сортування за алфавітом для консистентності
    /// 4. <strong>ToList():</strong> Матеріалізація результату в список
    /// 
    /// <strong>Обробка даних:</strong>
    /// - Працює з будь-якою колекцією що реалізує IEnumerable&lt;Todo&gt;
    /// - Обробляє порожні списки тегів без помилок
    /// - Зберігає нормалізацію тегів з бази даних
    /// 
    /// <strong>Застосування:</strong>
    /// - Генерація списків тегів для фільтрації
    /// - Автодоповнення при введенні тегів
    /// - Статистика використання тегів
    /// - Створення хмари тегів
    /// 
    /// <strong>Приклад використання:</strong>
    /// <code>
    /// var allTodos = await context.Todos.ToListAsync();
    /// var uniqueTags = allTodos.GetUniqueTagsFrom();
    /// // Результат: ["personal", "urgent", "work"] (відсортовано)
    /// </code>
    /// 
    /// <strong>Продуктивність:</strong>
    /// Операція має складність O(n*m + k*log(k)) де:
    /// - n = кількість завдань
    /// - m = середня кількість тегів на завдання  
    /// - k = кількість унікальних тегів
    /// 
    /// Для оптимізації великих наборів даних розгляньте кешування результату.
    /// </remarks>
    public static List<string> GetUniqueTagsFrom(this IEnumerable<Todo> todos)
    {
        return todos.SelectMany(t => t.Tags)
                   .Distinct()
                   .OrderBy(tag => tag)
                   .ToList();
    }
}